{"version":3,"file":"reactotron-core-client.js","sources":["../src/plugins/logger.ts","../src/plugins/image.ts","../src/plugins/benchmark.ts","../src/plugins/state-responses.ts","../src/plugins/api-response.ts","../src/plugins/clear.ts","../src/serialize.ts","../src/reactotron-core-client.ts","../src/validate.ts","../src/stopwatch.ts"],"sourcesContent":["/**\n * Provides 4 features for logging.  log & debug are the same.\n */\nexport default () => reactotron => {\n  return {\n    features: {\n      log: (...args) => {\n        const content = (args && args.length === 1) ? args[0] : args\n        reactotron.send(\"log\", { level: \"debug\", message: content }, false)\n      },\n      logImportant: (...args) => {\n        const content = (args && args.length === 1) ? args[0] : args\n        reactotron.send(\"log\", { level: \"debug\", message: content }, true)\n      },\n      debug: (message, important = false) =>\n        reactotron.send(\"log\", { level: \"debug\", message }, !!important),\n      warn: message => reactotron.send(\"log\", { level: \"warn\", message }, true),\n      error: (message, stack) => reactotron.send(\"log\", { level: \"error\", message, stack }, true),\n    },\n  }\n}\n","/**\n * Provides an image.\n */\nexport default () => reactotron => {\n  return {\n    features: {\n      // expanded just to show the specs\n      image: ({ uri, preview, filename, width, height, caption }) =>\n        reactotron.send(\"image\", { uri, preview, filename, width, height, caption }),\n    },\n  }\n}\n","/**\n * Runs small high-unscientific benchmarks for you.\n */\nexport default () => reactotron => {\n  const { startTimer } = reactotron\n\n  const benchmark = title => {\n    const steps = []\n    const elapsed = startTimer()\n    const step = stepTitle => {\n      const previousTime = steps.length === 0 ? 0 : (steps[steps.length - 1] as any).time\n      const nextTime = elapsed()\n      steps.push({ title: stepTitle, time: nextTime, delta: nextTime - previousTime })\n    }\n    steps.push({ title, time: 0, delta: 0 })\n    const stop = stopTitle => {\n      step(stopTitle)\n      reactotron.send(\"benchmark.report\", { title, steps })\n    }\n    return { step, stop, last: stop }\n  }\n\n  return {\n    features: { benchmark },\n  }\n}\n","/**\n * Provides helper functions for send state responses.\n */\nexport default () => reactotron => {\n  return {\n    features: {\n      stateActionComplete: (name, action, important = false) =>\n        reactotron.send(\"state.action.complete\", { name, action }, !!important),\n\n      stateValuesResponse: (path, value, valid = true) =>\n        reactotron.send(\"state.values.response\", { path, value, valid }),\n\n      stateKeysResponse: (path, keys, valid = true) =>\n        reactotron.send(\"state.keys.response\", { path, keys, valid }),\n\n      stateValuesChange: changes => reactotron.send(\"state.values.change\", { changes }),\n\n      // sends the state backup over to the server\n      stateBackupResponse: state => reactotron.send(\"state.backup.response\", { state }),\n    },\n  }\n}\n","\n/**\n * Sends API request/response information.\n */\nexport default () => reactotron => {\n  return {\n    features: {\n      apiResponse: (request, response, duration) => {\n        const ok =\n          response &&\n          response.status &&\n          typeof response.status === \"number\" &&\n          response.status >= 200 &&\n          response.status <= 299\n        const important = !ok\n        reactotron.send(\"api.response\", { request, response, duration }, important)\n      },\n    },\n  }\n}\n","/**\n * Clears the reactotron server.\n */\nexport default () => reactotron => {\n  return {\n    features: {\n      clear: () => reactotron.send(\"clear\"),\n    },\n  }\n}\n","// JSON.stringify() doesn't support circular dependencies or keeping\n// falsy values.  This does.\n//\n// Mostly adapted from https://github.com/isaacs/json-stringify-safe\n\n// replacement tokens\nconst UNDEFINED = \"~~~ undefined ~~~\"\nconst NULL = `~~~ null ~~~`\nconst FALSE = `~~~ false ~~~`\nconst ZERO = `~~~ zero ~~~`\nconst EMPTY_STRING = `~~~ empty string ~~~`\nconst CIRCULAR = \"~~~ Circular Reference ~~~\"\nconst ANONYMOUS = \"~~~ anonymous function ~~~\"\nconst INFINITY = \"~~~ Infinity ~~~\"\nconst NEGATIVE_INFINITY = \"~~~ -Infinity ~~~\"\n// const NAN = '~~~ NaN ~~~'\n\n/**\n * Attempts to give a name to a function.\n *\n * @param {Function} fn - The function to name.\n */\nfunction getFunctionName(fn: any): string {\n  const n = fn.name\n  if (n === null || n === undefined || n === \"\") {\n    return ANONYMOUS\n  } else {\n    return `~~~ ${n}() ~~~`\n  }\n}\n\n/**\n * Serializes an object to JSON.\n *\n *  @param {any} source - The victim.\n */\nfunction serialize(source) {\n  const stack = []\n  const keys = []\n\n  /**\n   * Replace this object node with something potentially custom.\n   *\n   * @param {*} key - The key currently visited.\n   * @param {*} value - The value to replace.\n   */\n  function serializer(replacer) {\n    return function(this: any, key, value) {\n      // slam dunks\n      if (value === true) return true\n\n      // weird stuff\n      // if (Object.is(value, NaN)) return NAN // OK, apparently this is hard... leaving out for now\n      if (value === Infinity) return INFINITY\n      if (value === -Infinity) return NEGATIVE_INFINITY\n      if (value === 0) return ZERO\n\n      // classic javascript\n      if (value === undefined) return UNDEFINED\n      if (value === null) return NULL\n      if (value === false) return FALSE\n\n      // head shakers\n      if (value === -0) return ZERO // eslint-disable-line\n      if (value === \"\") return EMPTY_STRING\n\n      // known types that have easy resolving\n      switch (typeof value) {\n        case \"string\":\n          return value\n        case \"number\":\n          return value\n        case \"function\":\n          return getFunctionName(value)\n      }\n\n      if (stack.length > 0) {\n        // check for prior existance\n        const thisPos = stack.indexOf(this)\n        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n        if (~stack.indexOf(value)) value = CIRCULAR\n      } else {\n        stack.push(value)\n      }\n\n      return replacer == null ? value : replacer.call(this, key, value)\n    }\n  }\n\n  return JSON.stringify(source, serializer(null))\n}\n\nexport default serialize\n","import * as WebSocket from \"ws\"\nimport validate from \"./validate\"\nimport logger from \"./plugins/logger\"\nimport image from \"./plugins/image\"\nimport benchmark from \"./plugins/benchmark\"\nimport stateResponses from \"./plugins/state-responses\"\nimport apiResponse from \"./plugins/api-response\"\nimport clear from \"./plugins/clear\"\nimport serialize from \"./serialize\"\nimport { start } from \"./stopwatch\"\nimport { ClientOptions } from \"./client-options\"\n\nexport const corePlugins = [\n  image(),\n  logger(),\n  benchmark(),\n  stateResponses(),\n  apiResponse(),\n  clear(),\n]\n\nconst DEFAULT_OPTIONS: ClientOptions = {\n  createSocket: null,\n  host: \"localhost\",\n  port: 9090,\n  name: \"reactotron-core-client\",\n  secure: false,\n  plugins: corePlugins,\n  safeRecursion: true,\n  onCommand: command => null,\n  onConnect: () => null,\n  onDisconnect: () => null,\n}\n\n// these are not for you.\nconst reservedFeatures = [\n  \"options\",\n  \"connected\",\n  \"socket\",\n  \"plugins\",\n  \"configure\",\n  \"connect\",\n  \"send\",\n  \"use\",\n  \"startTimer\",\n]\nconst isReservedFeature = (value: string) => reservedFeatures.some(res => res === value)\n\nfunction emptyPromise() {\n  return Promise.resolve(\"\")\n}\n\nexport interface CustomCommand {\n  id: number\n  command: string\n  handler: () => void\n}\n\nexport class Client {\n  // the configuration options\n  options: ClientOptions = Object.assign({}, DEFAULT_OPTIONS)\n\n  /**\n   * Are we connected to a server?\n   */\n  connected = false\n\n  /**\n   * The socket we're using.\n   */\n  socket: WebSocket = null\n\n  /**\n   * Available plugins.\n   */\n  plugins: any[] = []\n\n  /**\n   * Messages that need to be sent.\n   */\n  sendQueue: any[] = []\n\n  /**\n   * Are we ready to start communicating?\n   */\n  isReady = false\n\n  /**\n   * The last time we sent a message.\n   */\n  lastMessageDate = new Date()\n\n  /**\n   * The registered custom commands\n   */\n  customCommands: CustomCommand[] = []\n\n  /**\n   * The current ID for custom commands\n   */\n  customCommandLatestId: number = 1\n\n  /**\n   * Starts a timer and returns a function you can call to stop it and return the elapsed time.\n   */\n  startTimer = () => start()\n\n  /**\n   * Set the configuration options.\n   */\n  configure(options: ClientOptions = {}): Client {\n    // options get merged & validated before getting set\n    const newOptions = Object.assign({}, this.options, options)\n    validate(newOptions)\n    this.options = newOptions\n\n    // if we have plugins, let's add them here\n    if (Array.isArray(this.options.plugins)) {\n      this.options.plugins.forEach(p => this.use(p))\n    }\n\n    return this\n  }\n\n  close() {\n    this.connected = false\n    this.socket && this.socket.close && this.socket.close()\n  }\n\n  /**\n   * Connect to the Reactotron server.\n   */\n  connect(): Client {\n    this.connected = true\n    const {\n      createSocket,\n      secure,\n      host,\n      environment,\n      port,\n      name,\n      client = {},\n      getClientId,\n    } = this.options\n    const { onCommand, onConnect, onDisconnect } = this.options\n\n    // establish a connection to the server\n    const protocol = secure ? \"wss\" : \"ws\"\n    const socket = createSocket(`${protocol}://${host}:${port}`)\n\n    // fires when we talk to the server\n    const onOpen = () => {\n      // fire our optional onConnect handler\n      onConnect && onConnect()\n\n      // trigger our plugins onConnect\n      this.plugins.forEach(p => p.onConnect && p.onConnect())\n\n      const getClientIdPromise = getClientId ? getClientId : emptyPromise\n\n      getClientIdPromise().then(clientId => {\n        this.isReady = true\n        // introduce ourselves\n        this.send(\"client.intro\", {\n          environment,\n          ...client,\n          name,\n          clientId,\n          \"reactotronCoreClientVersion\": \"REACTOTRON_CORE_CLIENT_VERSION\",\n        })\n\n        // flush the send queue\n        while (this.sendQueue.length > 0) {\n          const h = this.sendQueue[0]\n          this.sendQueue = this.sendQueue.slice(1)\n          this.socket.send(h)\n        }\n      })\n    }\n\n    // fires when we disconnect\n    const onClose = () => {\n      this.isReady = false\n      // trigger our disconnect handler\n      onDisconnect && onDisconnect()\n\n      // as well as the plugin's onDisconnect\n      this.plugins.forEach(p => p.onDisconnect && p.onDisconnect())\n    }\n\n    // fires when we receive a command, just forward it off\n    const onMessage = (data: any) => {\n      const command = JSON.parse(data)\n      // trigger our own command handler\n      onCommand && onCommand(command)\n\n      // trigger our plugins onCommand\n      this.plugins.forEach(p => p.onCommand && p.onCommand(command))\n\n      // trigger our registered custom commands\n      if (command.type === \"custom\") {\n        this.customCommands.filter(cc => cc.command === command.payload).forEach(cc => cc.handler())\n      } else if (command.type === \"setClientId\") {\n        this.options.setClientId && this.options.setClientId(command.payload)\n      }\n    }\n\n    // this is ws style from require('ws') on node js\n    if (socket.on) {\n      socket.on(\"open\", onOpen)\n      socket.on(\"close\", onClose)\n      socket.on(\"message\", onMessage)\n    } else {\n      // this is a browser\n      socket.onopen = onOpen\n      socket.onclose = onClose\n      socket.onmessage = evt => onMessage(evt.data)\n    }\n\n    // assign the socket to the instance\n    this.socket = socket\n\n    return this\n  }\n\n  /**\n   * Sends a command to the server\n   */\n  send = (type, payload = {}, important = false) => {\n    // jet if we don't have a socket\n    if (!this.socket) {\n      return\n    }\n\n    // set the timing info\n    const date = new Date()\n    let deltaTime = date.getTime() - this.lastMessageDate.getTime()\n    // glitches in the matrix\n    if (deltaTime < 0) {\n      deltaTime = 0\n    }\n    this.lastMessageDate = date\n\n    const fullMessage = {\n      type,\n      payload,\n      important: !!important,\n      date: date.toISOString(),\n      deltaTime,\n    }\n\n    const serializedMessage = serialize(fullMessage)\n\n    if (this.isReady) {\n      // send this command\n      this.socket.send(serializedMessage)\n    } else {\n      // queue it up until we can connect\n      this.sendQueue.push(serializedMessage)\n    }\n  }\n\n  /**\n   * Sends a custom command to the server to displays nicely.\n   */\n  display(config: any = {}) {\n    const { name, value, preview, image: img, important = false } = config\n    const payload = {\n      name,\n      value: value || null,\n      preview: preview || null,\n      image: img || null,\n    }\n    this.send(\"display\", payload, important)\n  }\n\n  /**\n   * Client libraries can hijack this to report errors.\n   */\n  reportError(this: any, error) {\n    this.error(error)\n  }\n\n  /**\n   * Adds a plugin to the system\n   */\n  use(pluginCreator?: (client: Client) => any): Client {\n    // we're supposed to be given a function\n    if (typeof pluginCreator !== \"function\") {\n      throw new Error(\"plugins must be a function\")\n    }\n\n    // execute it immediately passing the send function\n    const plugin = pluginCreator.bind(this)(this)\n\n    // ensure we get an Object-like creature back\n    if (typeof plugin !== \"object\") {\n      throw new Error(\"plugins must return an object\")\n    }\n\n    // do we have features to mixin?\n    if (plugin.features) {\n      // validate\n      if (typeof plugin.features !== \"object\") {\n        throw new Error(\"features must be an object\")\n      }\n\n      // here's how we're going to inject these in\n      const inject = (key: string) => {\n        // grab the function\n        const featureFunction = plugin.features[key]\n\n        // only functions may pass\n        if (typeof featureFunction !== \"function\") {\n          throw new Error(`feature ${key} is not a function`)\n        }\n\n        // ditch reserved names\n        if (isReservedFeature(key)) {\n          throw new Error(`feature ${key} is a reserved name`)\n        }\n\n        // ok, let's glue it up... and lose all respect from elite JS champions.\n        this[key] = featureFunction\n      }\n\n      // let's inject\n      Object.keys(plugin.features).forEach(key => inject(key))\n    }\n\n    // add it to the list\n    this.plugins.push(plugin)\n\n    // call the plugins onPlugin\n    plugin.onPlugin && typeof plugin.onPlugin === \"function\" && plugin.onPlugin.bind(this)(this)\n\n    // chain-friendly\n    return this\n  }\n\n  onCustomCommand(command: string, handler: () => void): () => void {\n    // Create this command handlers object\n    const customHandler: CustomCommand = {\n      id: this.customCommandLatestId,\n      command,\n      handler,\n    }\n\n    // Increment our id counter\n    this.customCommandLatestId += 1\n\n    // Add it to our array\n    this.customCommands.push(customHandler)\n\n    this.send(\"customCommand.register\", { id: customHandler.id, command: customHandler.command })\n\n    return () => {\n      this.customCommands = this.customCommands.filter(cc => cc.id !== customHandler.id)\n\n      this.send(\"customCommand.unregister\", {\n        id: customHandler.id,\n        command: customHandler.command,\n      })\n    }\n  }\n}\n\n// convenience factory function\nexport function createClient (options?: ClientOptions) {\n  const client = new Client()\n  client.configure(options)\n  return client\n}\n","import * as WebSocket from \"ws\"\nimport { ClientOptions } from \"./client-options\"\n\nconst isCreateSocketValid = (createSocket: (path: string) => WebSocket) => typeof createSocket !== \"undefined\" && createSocket !== null\nconst isHostValid = (host: string): boolean => typeof host === \"string\" && host && host !== \"\"\nconst isPortValid = (port: number): boolean => typeof port === \"number\" && port >= 1 && port <= 65535\nconst onCommandValid = (fn: (cmd: string) => any) => typeof fn === \"function\"\n\n/**\n * Ensures the options are sane to run this baby.  Throw if not.  These\n * are basically sanity checks.\n */\nconst validate = (options: ClientOptions) => {\n  const { createSocket, host, port, onCommand } = options\n\n  if (!isCreateSocketValid(createSocket)) {\n    throw new Error(\"invalid createSocket function\")\n  }\n\n  if (!isHostValid(host)) {\n    throw new Error(\"invalid host\")\n  }\n\n  if (!isPortValid(port)) {\n    throw new Error(\"invalid port\")\n  }\n\n  if (!onCommandValid(onCommand)) {\n    throw new Error(\"invalid onCommand handler\")\n  }\n}\n\nexport default validate\n","/// <reference types=\"node\" />\n\ndeclare var global: any\n\nconst hasHirezNodeTimer =\n  false &&\n  typeof process === \"object\" &&\n  process &&\n  process.hrtime &&\n  typeof process.hrtime === \"function\"\n\n// the default timer\nconst defaultPerformanceNow = (started?: number) => Date.now()\n\n// try to find the browser-based performance timer\nconst nativePerformance =\n  typeof window !== \"undefined\" &&\n  window &&\n  (window.performance || (window as any).msPerformance || (window as any).webkitPerformance)\n\n// the function we're trying to assign\nlet performanceNow = defaultPerformanceNow\n\n// accepts an already started time and returns the number of milliseconds\nlet delta = (started: number) => performanceNow() - started\n\nif (hasHirezNodeTimer) {\n  performanceNow = process.hrtime as any\n  delta = started => performanceNow(started)[1] / 1000000\n} else if (global.nativePerformanceNow) {\n  // react native 47\n  performanceNow = global.nativePerformanceNow\n} else if (nativePerformance) {\n  // browsers + safely check for react native < 47\n  performanceNow = () => nativePerformance.now && nativePerformance.now()\n}\n\n/**\n * Starts a lame, low-res timer.  Returns a function which when invoked,\n * gives you the number of milliseconds since passing.  ish.\n */\nexport const start = () => {\n  //  record the start time\n  const started = performanceNow()\n  return () => delta(started)\n}\n"],"names":["reactotron","features","log","_i","args","content","length","send","level","message","logImportant","debug","important","warn","error","stack","image","_a","uri","preview","filename","width","height","caption","startTimer","benchmark","title","steps","elapsed","step","stepTitle","previousTime","time","nextTime","push","delta","stop","stopTitle","last","stateActionComplete","name","action","stateValuesResponse","path","value","valid","stateKeysResponse","keys","stateValuesChange","changes","stateBackupResponse","state","apiResponse","request","response","duration","status","clear","fn","n","undefined","ANONYMOUS","source","JSON","stringify","replacer","key","Infinity","INFINITY","NEGATIVE_INFINITY","ZERO","UNDEFINED","NULL","FALSE","EMPTY_STRING","getFunctionName","thisPos","indexOf","this","splice","CIRCULAR","call","serializer","Promise","resolve","options","client","Client","configure","isCreateSocketValid","createSocket","isHostValid","host","isPortValid","port","onCommandValid","validate","onCommand","Error","hasHirezNodeTimer","defaultPerformanceNow","started","Date","now","nativePerformance","window","performance","msPerformance","webkitPerformance","performanceNow","process","hrtime","global","nativePerformanceNow","start","corePlugins","logger","stateResponses","DEFAULT_OPTIONS","secure","plugins","safeRecursion","command","onConnect","onDisconnect","reservedFeatures","isReservedFeature","some","res","Object","assign","type","payload","_this","socket","date","deltaTime","getTime","lastMessageDate","serializedMessage","serialize","toISOString","isReady","sendQueue","newOptions","Array","isArray","forEach","p","use","connected","close","environment","_b","getClientId","_c","onOpen","emptyPromise","then","clientId","reactotronCoreClientVersion","h","slice","onClose","onMessage","data","parse","customCommands","filter","cc","handler","setClientId","on","onopen","onclose","onmessage","evt","config","img","pluginCreator","plugin","bind","inject_1","featureFunction","onPlugin","customHandler","id","customCommandLatestId"],"mappings":"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"}